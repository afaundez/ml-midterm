\documentclass[letterpaper, conference]{IEEEtran}

\usepackage{amsmath}
\DeclareMathOperator*{\argmax}{argmax}

\usepackage{pgfplots}
\pgfplotsset{compat=1.5.1}

\usepackage{titlesec}
\titlespacing*{\subsection}{0pt}{1.1\baselineskip}{\baselineskip}
\setlength{\parindent}{2em}
\setlength{\parskip}{0.7em}

\usepackage{url}

\begin{document}

\title{Midterm Report \\
  \large Machine Learning}

\author{
  \IEEEauthorblockN{Alvaro Faundez}
  \IEEEauthorblockA{
    \textit{Master in Data Science, first year}\\
    \textit{CUNY Graduate Center}\\
    \textit{alvaro@faundez.net}
  }
}

\maketitle

\begin{abstract}

The midterm project consists of the implementation of a discrete bayesian classifier. The subroutines include a dataset generator, training based on, and optimization of class conditional probabilities to maximize the expected gain. This report describes the steps that generate pseudo-random probabilities distributions, the dataset generation, the calculation of the Bayes decision rule, confusion matrix, and expected gain. The experimental results show that a 100\% expected gain is achievable in a few optimizations iterations.

\end{abstract}

\section{Introduction}

The Bayesian classifier is a popular predictive classifier broadly used in Machine Learning. Given a set of classes

\begin{equation} \label{classes}
C = \{c_1, ..., c_K\}
\end{equation}

and a measurement space

\begin{equation} \label{dimensions}
D = \times_{n=1}^{N}L_n
\end{equation}

the objective is to assign a class $c \in C$ for a specific measurement $d \in D$.

The critical step for the building of the Bayes decision rule is to calculate the posterior probability for a $d$:

\begin{equation} \label{eq:bayes}
P(c \mid d) \propto P(d \mid c) P(c)
\end{equation}

and use the economic gain matrix

\begin{equation}
  e =
  \begin{pmatrix}
    e(c_1,c_1) & \cdots & e(c_1,c_K) \\
      \vdots   & \ddots &    \vdots   \\
    e(c_K,c_1) & \cdots & c(c_K,c_K) 
  \end{pmatrix}
\end{equation}

to determine the $c_k$ with the highest economic gain

\begin{equation}
  \argmax_{c_k \in C} \sum_{j = 1}^{K} e(c_j, c_k)P(c_j, d)
\end{equation}

Then, the Bayes decision rule is defined as:

\begin{equation}
  f_d(c_m) = \left\{
  \begin{array}{lr}
  1 & m = k\\
  0 & m \neq k
  \end{array}\right\}
\end{equation}

The expected gain $E$, using an economic gain matrix $e$ is defined as follows:

\begin{equation}
  E[e, f] = \sum_{c \in C} \sum_{d \in D}f_d(c)e(c, c)P(c \mid d)
\end{equation}

This report details the implementation of a Bayesian classifier from scratch in the Ruby language, without any external scientific library. The subroutines include

\begin{itemize}

  \item Class and measurement dimensions definitions, including pseudo-random probabilities and cumulative distribution functions

  \item Space definition, calculating linear addresses, class conditional probabilities
 
  \item Data set definition, in charge of the prior probabilities, the Bayes decision rule, the confusion matrix, and the expected gain

\end{itemize}

These definitions provide tools to train and test using multiple pseudo-random generated datasets. The random seed is configurable by the user to get the same result in any iteration.

The classifier can be optimized after the training, maximizing the expected gain, modifying the class conditional probabilities using, and small perturbations.

The experimental results achieve a 100\% expecting gain after only a couple of iterations.

\section{Technical}

\subsection{Requirements}

To run the code, a Unix environment with Ruby 2.6+ is necessary. The code is available on GitHub at \url{https://github.com/afaundez/ml-midterm}.

To test the command and check the available options run

\begin{verbatim}
  $ ./midterm --help
\end{verbatim}

\subsection{options}

For the purpose of testing, the following parameters are available for configuration

\begin{itemize}
    \item-s, --seed [INT]                 Pseudo-random seed, an integer. Default: nil
    \item-c, --classes [INT]              Class cardinality, an integer. Default 2
    \item-m, --measurements [INT]         Measurements size, an integer. Default 5
    \item    --measurement-min-cardinality [INT]
                                     Measurement Min Cardinality, an integer. Default 3
    \item    --measurement-max-cardinality [INT]
                                     Measurement Max Cardinality, an integer. Default 6
    \item    --sample-size [INT]          Sample size, an integer. Default to 10 times the  space addresses size.
    \item-i, --iterations [INT]           Iterations, an integer. Default 2
    \item-d, --delta [FLOAT]              Delta for conditionals improvement, a float. Default: 0.01
    \item    --no-overlap                 Generate classes based on measurements
    \item    --uniform                    Use uniform distribution on all dimensions
\end{itemize}

\subsection{Runtime}

\subsubsection{Build}

During the build, three significant abstractions are used: Dimension, Space, and DataSet.

The Dimension abstraction is meant to store the cardinality, probabilities distribution function, and cumulative distribution function of a single measurement or class. A dimension does not store values, but it can be used to generate random values using the distribution functions. A Dimension is defined by:

\begin{itemize}
  \item size
  \item pdf, generated based on the size
  \item cdf, generate based on the pdf
  \item distribution, whether to use random or uniform distribution
\end{itemize}

The Space abstraction stores the single class dimension \ref{classes}, the collection of measurements dimensions \ref{dimensions}, and the class conditional probabilities. Since the Space knows all the dimensions specifications, it is in charge of translating and measurement into a linear address and vice-versa. A Space is defined by:

\begin{itemize}
\item class\_dimension, a Dimension instance
\item measurements\_dimensions, a collection of Dimension instances
\item likelihoods, random pdfs
\end{itemize}

The DataSet abstraction is in charge of generating and storing measurement values and the associated class, all bounded to a specific space. Since it has access to the data and space, it is in charge of the training and improving the class conditional probabilities, determining the Bayes Decision Rule, generating the Confusion Matrix, and calculating the Expected Gain. It is relevant that at the time of creating, the prior class probabilities are calculated and stored in the DataSet. A DataSet is defined by:
    
\begin{itemize}
\item size
\item space, a Space instance
\item samples, a collection of collections of measurements
\item class\_outcomes, counter of classes for prior class probabilities calculation
\item overlap, whether to assign classes with overlap
\end{itemize}

The Economic Gain Matrix is generated in this step. Even though it is a method, currently, the only matrix available is the identity matrix.

\subsubsection{Training}

Once a set of DataSet is created, the test DataSet is picked and left isolated, and the rest is used as train DataSet.

The training process consists of two steps: using the training set and an economic gain matrix, the training outputs the Bayes decision rule, and the expected gain. Then, using the Bayes decision rule, it generates the confusion matrix.


At the end of this process, the Space associated with the DataSet will store the measurement conditional probabilities $P(c \mid d)$ targeted in \ref{eq:bayes}.

\subsection{Optimization}

Now that the space is trained and the measurement conditional probabilities have been processed, using the delta as input, the dataset can improve the class conditional probabilities using the test DataSet. For each mismatched classification, the corresponding class conditional probability is incremented by the delta input, and the measurement probabilities are normalized to 1. This process yields an updated Space and accuracy obtained.

\section{Experimental Results}

Even though it is not a strict test, it is good to do a sanity check with a dummy case: one feature, one value measurement. It is expected to have an expected gain of 1.0 and an accuracy of 1.0.

Running

\begin{verbatim}
  bin/midterm --classes 1 --measurements 1
\end{verbatim}

yields, as expected,

\begin{verbatim}
Economic Gain Matrix
+---+
| 1 |
+---+

Train 0.
  Expected Gain: 1.0
  Confusion Matrix Trace: 1.0
  Accuracy: 1.0
Confusion Matrix
+-----+
| 1.0 |
+-----+

Test
  Expected Gain: 1.0
  Confusion Matrix Trace: 1.0
  Accuracy: 1.0
\end{verbatim}


The next step is to check the results using. Let us use two classes, five values measurements, and ten training sets, and start setting the seed number in order to have replicable experiments.

\subsection{First results}

\begin{verbatim}
  bin/midterm --classes 2 --measurements 5 \
    --iterations 10 --seed 1234
\end{verbatim}

The expected gain and accuracy do not seem to be correct

\begin{figure}[hbt]
  \label{fig:10-training-2-classes}
  \input{figures/10-training-2-classes}
  \caption{}
\end{figure}

Incrementing the training iterations to 100 does not make real improvements; it keeps going up and down.

\begin{figure}[hbt]
  \label{fig:100-training-2-classes}
  \input{figures/100-training-2-classes}
  \caption{}
\end{figure}

To identify the reason of these results, two options were added to the application, one to control the overlap in the class assignment to a measurement and how the probability distribution is generated.

\subsection{Probability distributions}

Since the method used to generate the probability distribution function for a dimension does not generate even probabilities for each value in the dimension, a parameter $--uniform$ was added to revert this and generate uniform distribution for the classes and measurement. The hypothesis was that by generating numbers evenly, the results would easier to understand.

Now, repeating the previous commands with the new parameter:

\begin{verbatim}
  bin/midterm --classes 2 --measurements 5 \
    --iterations 10 --seed 1234 \
    --uniform
\end{verbatim}

\begin{figure}[hbt]
  \label{fig:10-training-2-classes-uniform}
  \input{figures/10-training-2-classes-uniform}
  \caption{}
\end{figure}

The expected gain does not seem to be improving, but the accuracy is set around $0.5$. It could be a sign that accuracy is bouncing between that particular number because now each class has the same probability of being assign to a measurement. Using 100 training iterations, the result is similar.

\begin{figure}[hbt]
  \label{fig:100-training-2-classes-uniform}
  \input{figures/100-training-2-classes-uniform}
  \caption{}
\end{figure}

Checking with 3 classes, the accuracy bounce around $0.33$ as expected:

\begin{figure}[hbt]
  \label{fig:10-training-3-classes-uniform}
  \input{figures/10-training-3-classes-uniform}
  \caption{}
\end{figure}

\subsection{Class overlapping}

To understand if the accuracies shown in the previous steps are determined by the number of classes and the overlapping caused by an assignation independent from the measurements, it was added to the program the option to avoid the overlap and assign a class based on the norm of the measurement vector. This is an arbitrary assignment chosen just by the simplicity and certainty of the assignment's uniqueness.

using the new parameter

\begin{verbatim}
  bin/midterm --classes 2 --measurements 5 \
    --iterations 10 --seed 1234 \
    --no-overlap
\end{verbatim}

\begin{figure}[hbt]
  \label{fig:10-training-2-classes-no-overlapping}
  \input{figures/10-training-2-classes-no-overlapping}
  \caption{}
\end{figure}

Now the expected gain is considerably higher, and trying with 100 iterations stays close to 1.0.

\begin{figure}[hbt]
  \label{fig:100-training-2-classes-no-overlapping}
  \input{figures/100-training-2-classes-no-overlapping}
  \caption{}
\end{figure}

\section{Conclusions}

This report shows a Bayes classifier written from scratch in Ruby without any scientific library, following the theory and instructions provided during the Machine Learning class.

The program includes definitions and abstractions for Dimension, Space, and DataSet that can be configured with optional parameters through the command line to create classes, measurement, and training sets.

The initial results were not the one expected, showing low and bouncing expected gains and accuracy. As a way to explain these behaviors, two paths were developed

\begin{itemize}
  \item First, create the dimensions for classes and measurements using uniform probability distribution functions, expecting more recognizable numbers. The method worked, and it allowed us to determine that the accuracy was inversely proportional to the classes' cardinality.
  \item Then, with the conclusion from the previous step, it was introduced an option to assign a class to a specific measurement without overlapping. The norm of the measurement vector was the method used, and it produced a considerable impact on the expected gain and accuracy, reaching values over $0.99$ in both parameters.
\end{itemize}

Although some aspects of the value could have been explained with the overlapping of classes, it remains inconclusive why the expected gain and accuracy are not reaching 1.0 or why it does not stop bouncing.

\begin{thebibliography}{2}

\bibitem{discrete-bayes}
Robert M. Haralick,
\textit{Discrete Bayes Pattern Recognition}
\\\texttt{\url{http://haralick.org/ML/discrete_bayes.pdf}}

\bibitem{midterm-project}
Robert M. Haralick,
\textit{Midterm Project}
\\\texttt{\url{http://haralick.org/ML/midterm_project.pdf}}

\end{thebibliography}

\end{document}
  